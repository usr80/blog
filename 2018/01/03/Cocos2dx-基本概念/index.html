<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="glol23m@163.com"><title>Cocos2dx 基本概念 · KREEDX</title><meta name="description" content="基础概念介绍——导演、场景、层、精灵在Cocos2d-x-3.x引擎中，采用节点树形结构来管理游戏对象，一个游戏可以划分为不同的场景，一个场景又可以分为不同的层，一个层又可以拥有任意个可见的游戏节点（即对象，游戏中基本上所有的类都派生于节点类Node）。可以执行Action来修改游戏节点的属性，使其"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/blog/css/style.css"><link rel="stylesheet" href="/blog/css/blog_basic.css"><link rel="stylesheet" href="/blog/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/blog/images/logo@2x.png" style="width:127px;border-radius: 300px;"><h3 title=""><a href="/">KREEDX</a></h3><div class="description"><p>技术分享</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/u/6343727796?refer_flag=1001030201_&amp;is_all=1"><i class="fa fa-weibo"></i></a></li><li><a qq="1471699315" id="qq"><i class="fa fa-qq"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/blog">首页</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/blog/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Cocos2dx 基本概念</a></h3></div><div class="post-content"><h1 id="基础概念介绍——导演、场景、层、精灵"><a href="#基础概念介绍——导演、场景、层、精灵" class="headerlink" title="基础概念介绍——导演、场景、层、精灵"></a>基础概念介绍——导演、场景、层、精灵</h1><p>在Cocos2d-x-3.x引擎中，采用节点树形结构来管理游戏对象，一个游戏可以划分为不同的场景，一个场景又可以分为不同的层，一个层又可以拥有任意个可见的游戏节点（即对象，游戏中基本上所有的类都派生于节点类Node）。可以执行Action来修改游戏节点的属性，使其移动、旋转、放大、缩小等等。</p>
<p>每一个时刻都有一个场景在独立运行，通过切换不同的场景来完成一个游戏流程，游戏流程的管理由Director来执行，其基本框架类图如下:</p>
<p><img src="http://www.cocos.com/docs/native/v3/basic-concepts/res/frame.png" alt=""></p>
<h2 id="导演（Director）"><a href="#导演（Director）" class="headerlink" title="导演（Director）"></a>导演（Director）</h2><p>一款游戏好比一部电影，只是游戏具有更强的交互性，不过它们的基本原理是一致的。所以在Cocos2dx中把统筹游戏大局的类抽象为导演（Director），Director是整个cocos2dx引擎的核心，是整个游戏的导航仪，游戏中的一些常用操作就是由Director来控制的，比如OpenGL ES的初始化，场景的转换，游戏暂停继续的控制，世界坐标和GL坐标之间的切换，对节点（游戏元素）的控制等，还有一些游戏数据的保存调用，屏幕尺寸的获取等都要由Director类来管理控制的。</p>
<p>因为Director是游戏项目的总导演，会经常调用进行一些控制，所以该Director利用了单件设计模式，也就是项目里取到的director都是同一个。用getInstance() 方法取得Director的实例，具体的API可以参考相关文档，就不做赘述了。</p>
<h2 id="场景（Scene）"><a href="#场景（Scene）" class="headerlink" title="场景（Scene）"></a>场景（Scene）</h2><p>Scene场景也是cocos2dx中必不可少的元素，游戏中通常我们需要构建不同的场景（至少一个），游戏里关卡、版块的切换也就是一个一个场景的切换，就像在电影中变换舞台和场地一样。场景的一个重要的作用就是流程控制的作用，我们可以通过Director的一系列方法控制游戏中不同的场景的自由切换。</p>
<p>下面是Director控制场景的常用方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">runWithScene( Scene *scene ) 启动游戏，并运行scene场景。本方法在主程序第一次启动主场景的时候调用。如果已有正在运行的场景则不能调用该方法；会调用pushScene--&gt;startAnimation。</span><br><span class="line">pushScene( Scene *scene ) 将当前运行中的场景暂停并压入到代码执行场景栈中，再将传入的scene设置为当前运行场景，只有存在正在运行的场景时才调用该方法；</span><br><span class="line">replaceScene( Scene *scene ) 直接使用传入的scene替换当前场景来切换画面，当前场景被释放。这是切换场景时最常用的方法。</span><br><span class="line">popScene() 释放当前场景，再从代码执行场景中弹出栈顶的场景，并将其设置为当前运行场景。如果栈为空，直接结束应用。和PushScene结对使用</span><br><span class="line">end() 释放和终止执行场景，同时退出应用</span><br><span class="line">pause() 暂停当前运行场景中的所有计时器和动作，场景仍然会显示在屏幕上</span><br><span class="line">resume () 恢复当前运行场景的所有计时器和动作，场景仍然会显示在屏幕上</span><br></pre></td></tr></table></figure>
<p>同时场景是层的容器，包含了所有需要显示的游戏元素。通常，当我们需要完成一个场景时候，会创建一个Scene的子类，并在子类中实现我们需要的功能。比如，我们可以在子类的初始化中载入游戏资源，为场景添加层，启动音乐播放等等。</p>
<h2 id="层（Layer）"><a href="#层（Layer）" class="headerlink" title="层（Layer）"></a>层（Layer）</h2><p>Layer是处理玩家事件响应的Node子类。与场景不同，层通常包含的是直接在屏幕上呈现的内容，并且可以接受用户的输入事件，包括触摸，加速度计和键盘输入等。我们需要在层中加入精灵，文本标签或者其他游戏元素，并设置游戏元素的属性，比如位置，方向和大小；设置游戏元素的动作等。通常，层中的对象功能类似，耦合较紧，与层中游戏内容相关的逻辑代码也编写在层中，在组织好层后，只需要把层按照顺序添加到场景中就可以显示出来了。要向场景添加层，我们可以使用addChild方法。</p>
<p>addChild( Node child ) addChild( Node child, int zOrder ) addChild( Node *child, int zOrder, int tag )</p>
<p>其中，Child参数就是节点。对于场景而言，通常我们添加的节点就是层。先添加的层会被置于后添加的层之下。如果需要为它们指定先后次序，可以使用不同的zOrder值。tag是元素的标识号码，如果为子节点设置了tag值，就可以在它的父节点中利用tag值就可以找到它了。层可以包含任何Node作为子节点，包括Sprites(精灵), Labels(标签)，甚至其他的Layer对象。<br><img src="http://www.cocos.com/docs/native/v3/basic-concepts/res/layer.png" alt=""></p>
<p>上图所示的图片中，叫做HelloWorldScene的场景中有三个不同层，在layer3层上又有上个不同的精灵。</p>
<p>下面是一个创建三个不同层的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> layer = LayerColor::create(Color4B(<span class="number">0</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">255</span>));</span><br><span class="line">layer-&gt;setContentSize(CCSizeMake(<span class="number">120</span>, <span class="number">80</span>));</span><br><span class="line">layer-&gt;setPosition(Point(<span class="number">50</span>, <span class="number">50</span>));</span><br><span class="line">addChild(layer, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">auto</span> layer1 = LayerColor::create(Color4B(<span class="number">128</span>, <span class="number">0</span>, <span class="number">128</span>, <span class="number">255</span>));</span><br><span class="line">layer1-&gt;setContentSize(CCSizeMake(<span class="number">120</span>, <span class="number">80</span>));</span><br><span class="line">layer1-&gt;setPosition(Point(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">addChild(layer1, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">auto</span> layer2 = LayerColor::create(Color4B(<span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">layer2-&gt;setContentSize(CCSizeMake(<span class="number">120</span>, <span class="number">80</span>));</span><br><span class="line">layer2-&gt;setPosition(Point(<span class="number">150</span>, <span class="number">110</span>));</span><br><span class="line">addChild(layer2, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p><img src="http://www.cocos.com/docs/native/v3/basic-concepts/res/example.jpg" alt=""></p>
<h2 id="精灵"><a href="#精灵" class="headerlink" title="精灵"></a>精灵</h2><p>Cocos2d中的精灵和其他游戏引擎中的精灵相似，它可以移动，旋转，缩放，执行动画，并接受其他转换。Cocos2dx的Sprite由Texure，frame和animation组成，由openes负责渲染。主要的类关系如下:  简单过程可描述为：使用Texture2D加载图片，可以用Texture2D生成对应的SpriteFrame（精灵帧），将SpriteFrame添加到Animation生成动画数据，用Animation生成Animate（就是最终的动画动作），最后用Sprite执行这个动作。</p>
<p>创建精灵的几种方式：</p>
<p>直接创建:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sprite = Sprite::create(<span class="string">"HelloWorld.png"</span>);      </span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(sprite,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>使用纹理来创建精灵</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sprite1 = Sprite::createWithTexture(TextureCache::getInstance()-&gt;addImage(<span class="string">"HelloWorld.png"</span>));</span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(sprite1, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>使用精灵帧来创建精灵</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sprite2=Sprite::createWithSpriteFrameName(<span class="string">"HelloWorld.png"</span>);　　</span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(sprite2, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在Cocos2dx中实现精灵显示的基本过程如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Scene</span></span><br><span class="line"><span class="keyword">auto</span> scene = Scene::create();</span><br><span class="line"><span class="comment">//创建层</span></span><br><span class="line"><span class="keyword">auto</span> layer = HelloWorld::create();</span><br><span class="line"><span class="comment">//把层加入场景中</span></span><br><span class="line">scene-&gt;addChild(layer);</span><br><span class="line"><span class="comment">//创建一个精灵</span></span><br><span class="line"><span class="keyword">auto</span> sprite = Sprite::create(<span class="string">"HelloWorld.png"</span>);</span><br><span class="line"><span class="comment">//把精灵加到层里</span></span><br><span class="line">layer-&gt;addChild(sprite, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cocos.com/docs/native/v3/basic-concepts/zh.html" title="原文" target="_blank" rel="noopener">http://www.cocos.com/docs/native/v3/basic-concepts/zh.html</a></p>
<p><a href="http://zh.esotericsoftware.com/spine-user-guide" title="骨骼动画" target="_blank" rel="noopener">http://zh.esotericsoftware.com/spine-user-guide</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-01-03</span><i class="fa fa-tag"></i><a class="tag" href="/blog/tags/Cocos2dx/" title="Cocos2dx">Cocos2dx </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://usr80.github.io/blog/2018/01/03/Cocos2dx-基本概念/,KREEDX,Cocos2dx 基本概念,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/blog/2018/01/04/Tomcat部署SpringBoot工程/" title="Tomcat部署SpringBoot工程">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/blog/2018/01/03/Android笔记1/" title="Android笔记1">下一篇</a></li></ul></div><a id="comments"></a><div id="SOHUCS" sid="Cocos2dx 基本概念"></div><script src="//changyan.sohu.com/upload/changyan.js"></script><script>window.changyan.api.config({
 appid: 'cytkuIhD2',
 conf: 'prod_f1e563869dbea00ec11d6b96c647a8c4'
});
</script></div></div></div></div><script src="/blog/js/jquery.js"></script><script src="/blog/js/jquery-migrate-1.2.1.min.js"></script><script src="/blog/js/jquery.appear.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/bg.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/trianglify/0.4.0/trianglify.min.js"></script></body></html>