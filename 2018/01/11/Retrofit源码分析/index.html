<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="glol23m@163.com"><title>Retrofit源码分析 · KREEDX</title><meta name="description" content="Retrofit是对OKHttp的封装，简化了网络请求。具体使用参见官方文档。本文从一次完整的同步请求分析源码，跟着源码一起阅读，肯定会有收获的。分析的版本是retrofit-2.1.0。

老规矩，先上图。
类图
实例1234567891011121314151617181920212223242"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/blog/css/style.css"><link rel="stylesheet" href="/blog/css/blog_basic.css"><link rel="stylesheet" href="/blog/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/blog/images/logo@2x.png" style="width:127px;border-radius: 300px;"><h3 title=""><a href="/">KREEDX</a></h3><div class="description"><p>技术分享</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/u/6343727796?refer_flag=1001030201_&amp;is_all=1"><i class="fa fa-weibo"></i></a></li><li><a qq="1471699315" id="qq"><i class="fa fa-qq"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/blog">首页</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/blog/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Retrofit源码分析</a></h3></div><div class="post-content"><blockquote>
<p>Retrofit是对OKHttp的封装，简化了网络请求。具体使用参见官方文档。本文从一次完整的同步请求分析源码，跟着源码一起阅读，肯定会有收获的。分析的版本是retrofit-2.1.0。</p>
</blockquote>
<p>老规矩，先上图。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/3170566-49001674a994b813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnRetrofit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_URL = <span class="string">"https://api.github.com"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//创建接口</span></span><br><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">        <span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">contributors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Path(<span class="string">"owner"</span>)</span> String owner,</span></span><br><span class="line"><span class="function">            @<span class="title">Path</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建Retrofit对象</span></span><br><span class="line">        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(API_URL)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态生成一个代理对象</span></span><br><span class="line">        GitHub github = retrofit.create(GitHub.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一个OKHttpCall的代理对象</span></span><br><span class="line">        Call&lt;ResponseBody&gt; call = github.contributors(<span class="string">"square"</span>, <span class="string">"retrofit"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        Response&lt;ResponseBody&gt; response = call.execute();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打印数据</span></span><br><span class="line">        System.out.println(response.body().string());</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从官方文档里的一个例子开始。我做了一些修改，开始不使用GsonConverter对结果进行转换，后面会添加，在默认情况下Retrofit只支持将HTTP的响应体转换换为ResponseBody（OKHttp中的类），默认情况下Retrofit使用BuiltInConverters这个默认的Converter，后面会再次提到。第一步，创建一个接口。第二步，创建一个Retrofit对象，提供BASE_URL等信息。第三步，创建一个实现了接口的代理对象。第四步，调用接口方法，返回一个Call对象。第五步，调用execute执行同步请求。第六步，从响应获取数据。我们跟着步骤一步一步分析。</p>
<h2 id="创建Call"><a href="#创建Call" class="headerlink" title="创建Call"></a>创建Call</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Proxy.newProxyInstance（）返回一个Github的代理类对象</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个invoke方法会在代理对象的方法中调用，第一个参数就是代理对象</span></span><br><span class="line">        <span class="comment">//第二个参数是代理对象调用的方法</span></span><br><span class="line">        <span class="comment">//第三个参数方法的参数</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">         <span class="comment">//调用loadMethodHandler</span></span><br><span class="line">          <span class="keyword">return</span> loadMethodHandler(method).invoke(args);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了动态代理，Proxy.newProxyInstance（）返回一个Github的代理类对象。当我们调用github这个代理对象的方法比如contributors()时，会调用调用上述的invoke方法，第一个参数就是代理对象，第二个参数是代理对象调用的方法，第三个参数是方法的参数。动态代理可以看我以前的写的文章，建议完全搞懂动态代理，然后往下看。假设现在我调用了github.contributors(“square”, “retrofit”)那么会调用invoke方法，然后调用loadMethodHandler()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MethodHandler <span class="title">loadMethodHandler</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">  MethodHandler handler;</span><br><span class="line">  <span class="keyword">synchronized</span> (methodHandlerCache) &#123;</span><br><span class="line">    handler = methodHandlerCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//创建MethodHandler 对象</span></span><br><span class="line">      handler = MethodHandler.create(<span class="keyword">this</span>, method);</span><br><span class="line">      methodHandlerCache.put(method, handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>loadMethodHandler()返回一个MethodHandler对象，然后调用这个对象的invoke（）方法。我们看下这个类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//核心成员变量</span><br><span class="line">  private final okhttp3.Call.Factory callFactory;</span><br><span class="line">  private final RequestFactory requestFactory;</span><br><span class="line">  private final CallAdapter&lt;?&gt; callAdapter;</span><br><span class="line">  private final Converter&lt;ResponseBody, ?&gt; responseConverter;</span><br><span class="line"></span><br><span class="line">//核心方法</span><br><span class="line">  static MethodHandler create(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    //创建CallAdapter</span><br><span class="line">    CallAdapter&lt;?&gt; callAdapter = createCallAdapter(method, retrofit);</span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    if (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">      throw Utils.methodError(method, &quot;&apos;&quot;</span><br><span class="line">          + Types.getRawType(responseType).getName()</span><br><span class="line">          + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   //创建Converter</span><br><span class="line">    Converter&lt;ResponseBody, ?&gt; responseConverter =</span><br><span class="line">        createResponseConverter(method, retrofit, responseType);</span><br><span class="line">    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);</span><br><span class="line">    return new MethodHandler(retrofit.callFactory(), requestFactory, callAdapter,</span><br><span class="line">        responseConverter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//创建CallAdapter</span><br><span class="line">  private static CallAdapter&lt;?&gt; createCallAdapter(Method method, Retrofit retrofit) &#123;</span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    if (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      throw Utils.methodError(method,</span><br><span class="line">          &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    if (returnType == void.class) &#123;</span><br><span class="line">      throw Utils.methodError(method, &quot;Service methods cannot return void.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    try &#123;</span><br><span class="line">      //调用Retrofit.callAdapter（）</span><br><span class="line">      return retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</span><br><span class="line">      throw Utils.methodError(e, method, &quot;Unable to create call adapter for %s&quot;, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//创建Converter</span><br><span class="line">  private static Converter&lt;ResponseBody, ?&gt; createResponseConverter(Method method,</span><br><span class="line">      Retrofit retrofit, Type responseType) &#123;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    try &#123;</span><br><span class="line">      //调用Retrofit.responseBodyConverter（）方法</span><br><span class="line">      return retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.</span><br><span class="line">      throw Utils.methodError(e, method, &quot;Unable to create converter for %s&quot;, responseType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在创建MethodHandler这个类的时候，我要创建一个CallAdapter和一个Converter，从流程看，分别调用retrofit.callAdapter(returnType, annotations);和retrofit.responseBodyConverter(responseType, annotations);创建。Retrofit的这两个方法最终调用如下两个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CallAdapter&lt;?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">    Annotation[] annotations) &#123;</span><br><span class="line">  checkNotNull(returnType, <span class="string">"returnType == null"</span>);</span><br><span class="line">  checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> start = adapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    <span class="comment">//从adapterFactories这个LIst获取</span></span><br><span class="line">    CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate call adapter for "</span>)</span><br><span class="line">      .append(returnType)</span><br><span class="line">      .append(<span class="string">".\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> (skipPast != <span class="keyword">null</span>) &#123;</span><br><span class="line">    builder.append(<span class="string">"  Skipped:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">      builder.append(<span class="string">"\n   * "</span>).append(adapterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">'\n'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  builder.append(<span class="string">"  Tried:"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    builder.append(<span class="string">"\n   * "</span>).append(adapterFactories.get(i).getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;T, RequestBody&gt; <span class="title">nextRequestBodyConverter</span><span class="params">(Converter.Factory skipPast,</span></span></span><br><span class="line"><span class="function"><span class="params">    Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations)</span> </span>&#123;</span><br><span class="line">  checkNotNull(type, <span class="string">"type == null"</span>);</span><br><span class="line">  checkNotNull(parameterAnnotations, <span class="string">"parameterAnnotations == null"</span>);</span><br><span class="line">  checkNotNull(methodAnnotations, <span class="string">"methodAnnotations == null"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    <span class="comment">//从converterFactories这个List获取</span></span><br><span class="line">    Converter.Factory factory = converterFactories.get(i);</span><br><span class="line">    Converter&lt;?, RequestBody&gt; converter =</span><br><span class="line">        factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="keyword">return</span> (Converter&lt;T, RequestBody&gt;) converter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate RequestBody converter for "</span>)</span><br><span class="line">      .append(type)</span><br><span class="line">      .append(<span class="string">".\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> (skipPast != <span class="keyword">null</span>) &#123;</span><br><span class="line">    builder.append(<span class="string">"  Skipped:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">      builder.append(<span class="string">"\n   * "</span>).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">'\n'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  builder.append(<span class="string">"  Tried:"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    builder.append(<span class="string">"\n   * "</span>).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个方法分别从adapterFactories和converterFactories获取一个CallAdapter和Converter，我们看下这两个List是如何构造的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">  <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建List保存CallAdapter.Factory</span></span><br><span class="line">  List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.adapterFactories);</span><br><span class="line">  <span class="comment">//添加一个默认的CallAdapterFactory</span></span><br><span class="line">adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建List保存Converter.Factory</span></span><br><span class="line">  List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.converterFactories);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</span><br><span class="line">      callbackExecutor, validateEagerly);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">  <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line"> <span class="comment">//添加默认的ConverterFactory</span></span><br><span class="line">  converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们在构造Retrofit时没有提供CallAdaCallAdapter.Factory和Converter.Factory，构造时会使用默认值，我看看下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//添加默认CallAdapterFactory</span><br><span class="line">adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));   </span><br><span class="line"></span><br><span class="line">//最终是这个类</span><br><span class="line">final class DefaultCallAdapterFactory extends CallAdapter.Factory &#123;</span><br><span class="line">  static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    if (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">    //返回匿名CallAdapter类</span><br><span class="line">    return new CallAdapter&lt;Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      @Override public Type responseType() &#123;</span><br><span class="line">        return responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) &#123;</span><br><span class="line">        return call;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到DefaultCallAdapterFactory生成的匿名CallAdapter类的adapt方法把call原封不动得传回。再来看看RequestBodyConverter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static final class RequestBodyConverter implements Converter&lt;RequestBody, RequestBody&gt; &#123;</span><br><span class="line">  static final RequestBodyConverter INSTANCE = new RequestBodyConverter();</span><br><span class="line">  </span><br><span class="line">   //将RequestBody原封不动返回，不做任何处理</span><br><span class="line">  @Override public RequestBody convert(RequestBody value) throws IOException &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，到这里我们总结下，我们创建了一个MethodHandler对象，创建过程中，我们又创建了一个默认的CallAdapter和一个默认的RequestBodyConverter 。创建完了MethodHandler，我们调用了它的invoke（）方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object invoke(Object... args) &#123;</span><br><span class="line">  return callAdapter.adapt(</span><br><span class="line">      new OkHttpCall&lt;&gt;(callFactory, requestFactory, args, responseConverter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里使用了我们刚才创建的默认的CallAdapter，上面我们知道它的adapt（）仅仅是返回参数，其他什么都不做。所以这里返回的是一个OkHttpCall对象。这个OkHttpCall实现了Call<t>接口。我们总结下，到现在为止，我们仅仅调用了这两句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//动态生成一个代理对象</span><br><span class="line">GitHub github = retrofit.create(GitHub.class);</span><br><span class="line"></span><br><span class="line">//生成一个OKHttpCall的代理对象</span><br><span class="line">Call&lt;ResponseBody&gt; call = github.contributors(&quot;square&quot;, &quot;retrofit&quot;);</span><br></pre></td></tr></table></figure></t></p>
<p>所以我们知道Call<responsebody> call = github.contributors(“square”, “retrofit”)返回的就是OkHttpCall对象。接下来我们应该调用Response<responsebody> response = call.execute();，我们看下OkHttpCall的execute方法。<br>调用call.execute()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">//核心成员变量</span><br><span class="line">  private final okhttp3.Call.Factory callFactory;</span><br><span class="line">  private final RequestFactory requestFactory;</span><br><span class="line">  private final Object[] args;</span><br><span class="line">  private final Converter&lt;ResponseBody, T&gt; responseConverter;</span><br><span class="line"></span><br><span class="line">//核心方法</span><br><span class="line">  @Override public Response&lt;T&gt; execute() throws IOException &#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);</span><br><span class="line">      executed = true;</span><br><span class="line"></span><br><span class="line">      if (creationFailure != null) &#123;</span><br><span class="line">        if (creationFailure instanceof IOException) &#123;</span><br><span class="line">          throw (IOException) creationFailure;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          throw (RuntimeException) creationFailure;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      call = rawCall;</span><br><span class="line">      if (call == null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           //将任务抛给OKHttp</span><br><span class="line">          call = rawCall = createRawCall();</span><br><span class="line">        &#125; catch (IOException | RuntimeException e) &#123;</span><br><span class="line">          creationFailure = e;</span><br><span class="line">          throw e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (canceled) &#123;</span><br><span class="line">      call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    //转换结果</span><br><span class="line">    return parseResponse(call.execute());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> //生成okhttp3.Call</span><br><span class="line">  private okhttp3.Call createRawCall() throws IOException &#123;</span><br><span class="line">    //这个callFactory就是OKHttpClient</span><br><span class="line">    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">    if (call == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> //将okhttp3.Response转换成Response</span><br><span class="line">  Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</span><br><span class="line">    ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">    // Remove the body&apos;s source (the only stateful object) so we can pass the response along.</span><br><span class="line">    rawResponse = rawResponse.newBuilder()</span><br><span class="line">        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    int code = rawResponse.code();</span><br><span class="line">    if (code &lt; 200 || code &gt;= 300) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        // Buffer the entire body to avoid future I/O.</span><br><span class="line">        ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">        return Response.error(bufferedBody, rawResponse);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        rawBody.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (code == 204 || code == 205) &#123;</span><br><span class="line">      return Response.success(null, rawResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">    try &#123;</span><br><span class="line">      //这个responseconverter就是默认提供的RequestBodyConverter，当然我们可以替换成自己的converter比如GsonConverter</span><br><span class="line">      T body = responseConverter.convert(catchingBody);</span><br><span class="line">      return Response.success(body, rawResponse);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">      // If the underlying source threw an exception, propagate that rather than indicating it was</span><br><span class="line">      // a runtime exception.</span><br><span class="line">      catchingBody.throwIfCaught();</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></responsebody></responsebody></p>
<p>好了，再次总结下，我们调用了OKHttpCall.execute（），该方法生成一个okhttp3.Call将任务抛给OKHttp，完了调用parseResponse，用Converter将okhttp3.Response转换成我们在范型中指定的类型Response<responsebody> response = call.execute()，我指定了okhttp3.ResonseBody。然后返回结果。如果我在构造Retrofit时提供了GsonConverter，addConverterFactory(GsonConverterFactory.create())那么上面的T body = responseConverter.convert(catchingBody);responseConverter就是GsonConverter。<br>总结</responsebody></p>
<p>Retrofit就是对OkHttp的包装，了解原理后我们将更好地使用它。</p>
<p>作者：gatsby_dhn<br>链接：<a href="https://www.jianshu.com/p/097947afddaf" target="_blank" rel="noopener">https://www.jianshu.com/p/097947afddaf</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-01-11</span><i class="fa fa-tag"></i><a class="tag" href="/blog/tags/Android/" title="Android">Android </a><a class="tag" href="/blog/tags/Retrofit/" title="Retrofit">Retrofit </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://usr80.github.io/blog/2018/01/11/Retrofit源码分析/,KREEDX,Retrofit源码分析,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/blog/2018/01/11/OkHttp/" title="OkHttp">下一篇</a></li></ul></div><a id="comments"></a><div id="SOHUCS" sid="Retrofit源码分析"></div><script src="//changyan.sohu.com/upload/changyan.js"></script><script>window.changyan.api.config({
 appid: 'cytkuIhD2',
 conf: 'prod_f1e563869dbea00ec11d6b96c647a8c4'
});
</script></div></div></div></div><script src="/blog/js/jquery.js"></script><script src="/blog/js/jquery-migrate-1.2.1.min.js"></script><script src="/blog/js/jquery.appear.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/bg.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/trianglify/0.4.0/trianglify.min.js"></script><script src="https://s19.cnzz.com/z_stat.php?id=1272173729&amp;web_id=1272173729"></script></body></html>